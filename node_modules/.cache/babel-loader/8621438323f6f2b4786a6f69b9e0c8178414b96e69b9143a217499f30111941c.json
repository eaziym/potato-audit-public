{"ast":null,"code":"import React,{useEffect,useRef,useState}from'react';import LabelVariationsModal from'./LabelVariationsModal';// Import the modal component\nimport{jsx as _jsx,jsxs as _jsxs,Fragment as _Fragment}from\"react/jsx-runtime\";function findTextForCoordinates(blobCoordinates,mergedTexts){const[x1,y1,width1,height1]=blobCoordinates;for(const{coordinates:[x2,y2,width2,height2],text}of mergedTexts){// This is a simple overlap check, you might need a more sophisticated comparison\nif(x1===x2&&y1===y2&&width1===width2&&height1===height2){console.log(\"Matching text found for coordinates:\",blobCoordinates);return text;}}console.log(\"No matching text found for coordinates:\",blobCoordinates);return null;// No matching text found\n}function InteractiveAnnotatedImage(_ref){let{imagePath,blobs,mergedTexts,onSelectionComplete,onLabelVariationsUpdate}=_ref;const imageRef=useRef(null);const[scaleFactor,setScaleFactor]=useState(1);const[selectedPairs,setSelectedPairs]=useState([]);const[currentPair,setCurrentPair]=useState([]);const[selectionCount,setSelectionCount]=useState({});const[isVariationsModalOpen,setIsVariationsModalOpen]=useState(false);const[currentLabelIndex,setCurrentLabelIndex]=useState(null);// Track the current label for variations\nconst[currentLabelText,setCurrentLabelText]=useState('');const[labelVariations,setLabelVariations]=useState({});// Store label variations\n// This function might be triggered when a pair is fully selected\nconst openLabelVariationsModal=labelText=>{setCurrentLabelText(labelText);// Set the actual text, not the index\nsetIsVariationsModalOpen(true);};const handleSaveVariations=(labelText,variationsArray)=>{// Update labelVariations state to include new variations for the labelText\nsetLabelVariations(prevVariations=>({...prevVariations,[labelText]:variationsArray// Use labelText as key\n}));setIsVariationsModalOpen(false);};const handleCancelModal=()=>{setIsVariationsModalOpen(false);// Close the modal on cancel\n};useEffect(()=>{onSelectionComplete(selectedPairs);// Only call onLabelVariationsUpdate if it's defined\nif(onLabelVariationsUpdate){onLabelVariationsUpdate(labelVariations);// Update parent component with label variations\n}},[selectedPairs,labelVariations,onSelectionComplete,onLabelVariationsUpdate]);useEffect(()=>{const calculateScaleFactor=()=>{if(imageRef.current){const naturalWidth=imageRef.current.naturalWidth;const displayWidth=imageRef.current.clientWidth;if(naturalWidth&&displayWidth){setScaleFactor(displayWidth/naturalWidth);}}};if(imageRef.current){if(imageRef.current.complete){calculateScaleFactor();}else{imageRef.current.onload=calculateScaleFactor;}}window.addEventListener('resize',calculateScaleFactor);return()=>window.removeEventListener('resize',calculateScaleFactor);},[imagePath]);useEffect(()=>{onSelectionComplete(selectedPairs);},[selectedPairs,onSelectionComplete]);const addSelection=index=>{if(selectionCount[index]>=2)return;const updatedCurrentPair=[...currentPair,index];const updatedSelectionCount={...selectionCount,[index]:(selectionCount[index]||0)+1};if(updatedCurrentPair.length===2){setSelectedPairs([...selectedPairs,updatedCurrentPair]);setCurrentPair([]);}else{setCurrentPair(updatedCurrentPair);}setSelectionCount(updatedSelectionCount);if(updatedCurrentPair.length===2){// Assuming the first item is the index for the blob\nconst blobCoordinates=blobs[updatedCurrentPair[0]].coordinates;// Find the matching text for these coordinates in mergedTexts\nconst labelText=findTextForCoordinates(blobCoordinates,mergedTexts);if(labelText){openLabelVariationsModal(labelText);}}};const undoSelection=()=>{let lastSelectedIndex;if(currentPair.length>0){lastSelectedIndex=currentPair.pop();setCurrentPair([...currentPair]);}else if(selectedPairs.length>0){const lastPair=selectedPairs[selectedPairs.length-1];lastSelectedIndex=lastPair.pop();if(lastPair.length===0){selectedPairs.pop();}else{selectedPairs[selectedPairs.length-1]=lastPair;}setSelectedPairs([...selectedPairs]);}if(lastSelectedIndex!==undefined){const updatedSelectionCount={...selectionCount};if(updatedSelectionCount[lastSelectedIndex]>0){updatedSelectionCount[lastSelectedIndex]--;}setSelectionCount(updatedSelectionCount);}};const getLabel=index=>{const occurrences=selectedPairs.flat().filter(i=>i===index).length+(currentPair.includes(index)?1:0);let label='';selectedPairs.forEach((pair,pairIndex)=>{pair.forEach((elementIndex,elementPosition)=>{if(elementIndex===index){label+=\"\".concat(pairIndex+1).concat(elementPosition===0?'A':'B',\" \");}});});if(currentPair.includes(index)&&occurrences<2){label+=\"\".concat(selectedPairs.length+1,\"A \");}return label.trim();};return/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(\"button\",{onClick:undoSelection,className:\"undo-button\",children:\"Undo Selection\"}),/*#__PURE__*/_jsxs(\"div\",{style:{position:'relative',display:'inline-block'},children:[/*#__PURE__*/_jsx(\"img\",{ref:imageRef,src:imagePath,alt:\"Annotated Invoice\",style:{maxWidth:'100%'}}),/*#__PURE__*/_jsx(\"svg\",{style:{position:'absolute',top:0,left:0,width:'100%',height:'100%'},children:blobs.map((blob,index)=>{const[x,y,width,height]=blob.coordinates.map(coord=>coord*scaleFactor);const isSelected=selectedPairs.flat().includes(index)||currentPair.includes(index);const label=getLabel(index);return/*#__PURE__*/_jsxs(\"g\",{onClick:()=>addSelection(index),children:[/*#__PURE__*/_jsx(\"rect\",{x:x,y:y,width:width,height:height,fill:\"none\",stroke:isSelected?'blue':'red',strokeWidth:\"2\",style:{pointerEvents:'all',cursor:'pointer'}}),label&&/*#__PURE__*/_jsx(\"text\",{x:x+5,y:y+20,fill:\"blue\",fontSize:\"15\",style:{pointerEvents:'none'},children:label})]},index);})})]}),isVariationsModalOpen&&/*#__PURE__*/_jsx(LabelVariationsModal,{isOpen:isVariationsModalOpen,onSave:handleSaveVariations,onCancel:handleCancelModal,currentLabelText:currentLabelText})]});}export default InteractiveAnnotatedImage;","map":{"version":3,"names":["React","useEffect","useRef","useState","LabelVariationsModal","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","findTextForCoordinates","blobCoordinates","mergedTexts","x1","y1","width1","height1","coordinates","x2","y2","width2","height2","text","console","log","InteractiveAnnotatedImage","_ref","imagePath","blobs","onSelectionComplete","onLabelVariationsUpdate","imageRef","scaleFactor","setScaleFactor","selectedPairs","setSelectedPairs","currentPair","setCurrentPair","selectionCount","setSelectionCount","isVariationsModalOpen","setIsVariationsModalOpen","currentLabelIndex","setCurrentLabelIndex","currentLabelText","setCurrentLabelText","labelVariations","setLabelVariations","openLabelVariationsModal","labelText","handleSaveVariations","variationsArray","prevVariations","handleCancelModal","calculateScaleFactor","current","naturalWidth","displayWidth","clientWidth","complete","onload","window","addEventListener","removeEventListener","addSelection","index","updatedCurrentPair","updatedSelectionCount","length","undoSelection","lastSelectedIndex","pop","lastPair","undefined","getLabel","occurrences","flat","filter","i","includes","label","forEach","pair","pairIndex","elementIndex","elementPosition","concat","trim","children","onClick","className","style","position","display","ref","src","alt","maxWidth","top","left","width","height","map","blob","x","y","coord","isSelected","fill","stroke","strokeWidth","pointerEvents","cursor","fontSize","isOpen","onSave","onCancel"],"sources":["/Users/msy/Desktop/Shiyao/repo/potato-audit/src/InteractiveAnnotatedImage.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport LabelVariationsModal from './LabelVariationsModal'; // Import the modal component\n\nfunction findTextForCoordinates(blobCoordinates, mergedTexts) {\n  const [x1, y1, width1, height1] = blobCoordinates;\n  for (const { coordinates: [x2, y2, width2, height2], text } of mergedTexts) {\n      // This is a simple overlap check, you might need a more sophisticated comparison\n      if (x1 === x2 && y1 === y2 && width1 === width2 && height1 === height2) {\n          console.log(\"Matching text found for coordinates:\", blobCoordinates);\n          return text;\n      }\n  }\n  console.log(\"No matching text found for coordinates:\", blobCoordinates);\n  return null; // No matching text found\n}\n\nfunction InteractiveAnnotatedImage({ imagePath, blobs, mergedTexts, onSelectionComplete,  onLabelVariationsUpdate }) {\n  const imageRef = useRef(null);\n  const [scaleFactor, setScaleFactor] = useState(1);\n  const [selectedPairs, setSelectedPairs] = useState([]);\n  const [currentPair, setCurrentPair] = useState([]);\n  const [selectionCount, setSelectionCount] = useState({});\n  const [isVariationsModalOpen, setIsVariationsModalOpen] = useState(false);\n  const [currentLabelIndex, setCurrentLabelIndex] = useState(null); // Track the current label for variations\n  const [currentLabelText, setCurrentLabelText] = useState('');\n  const [labelVariations, setLabelVariations] = useState({}); // Store label variations\n  \n  // This function might be triggered when a pair is fully selected\n  const openLabelVariationsModal = (labelText) => {\n    setCurrentLabelText(labelText); // Set the actual text, not the index\n    setIsVariationsModalOpen(true);\n  };\n\n\n\n  const handleSaveVariations = (labelText, variationsArray) => {\n    // Update labelVariations state to include new variations for the labelText\n    setLabelVariations(prevVariations => ({\n      ...prevVariations,\n      [labelText]: variationsArray // Use labelText as key\n    }));\n    setIsVariationsModalOpen(false);\n  };\n\n  const handleCancelModal = () => {\n    setIsVariationsModalOpen(false); // Close the modal on cancel\n  };\n\n  useEffect(() => {\n    onSelectionComplete(selectedPairs);\n    // Only call onLabelVariationsUpdate if it's defined\n    if (onLabelVariationsUpdate) {\n      onLabelVariationsUpdate(labelVariations); // Update parent component with label variations\n    }\n  }, [selectedPairs, labelVariations, onSelectionComplete, onLabelVariationsUpdate]);\n\n  useEffect(() => {\n    const calculateScaleFactor = () => {\n      if (imageRef.current) {\n        const naturalWidth = imageRef.current.naturalWidth;\n        const displayWidth = imageRef.current.clientWidth;\n        if (naturalWidth && displayWidth) {\n          setScaleFactor(displayWidth / naturalWidth);\n        }\n      }\n    };\n\n    if (imageRef.current) {\n      if (imageRef.current.complete) {\n        calculateScaleFactor();\n      } else {\n        imageRef.current.onload = calculateScaleFactor;\n      }\n    }\n\n    window.addEventListener('resize', calculateScaleFactor);\n    return () => window.removeEventListener('resize', calculateScaleFactor);\n  }, [imagePath]);\n\n  useEffect(() => {\n    onSelectionComplete(selectedPairs);\n  }, [selectedPairs, onSelectionComplete]);\n\n  const addSelection = (index) => {\n    if (selectionCount[index] >= 2) return;\n\n    const updatedCurrentPair = [...currentPair, index];\n    const updatedSelectionCount = { ...selectionCount, [index]: (selectionCount[index] || 0) + 1 };\n\n    if (updatedCurrentPair.length === 2) {\n      setSelectedPairs([...selectedPairs, updatedCurrentPair]);\n      setCurrentPair([]);\n    } else {\n      setCurrentPair(updatedCurrentPair);\n    }\n    setSelectionCount(updatedSelectionCount);\n\n    if (updatedCurrentPair.length === 2) {\n        // Assuming the first item is the index for the blob\n        const blobCoordinates = blobs[updatedCurrentPair[0]].coordinates;\n        // Find the matching text for these coordinates in mergedTexts\n        const labelText = findTextForCoordinates(blobCoordinates, mergedTexts);\n        if (labelText) {\n            openLabelVariationsModal(labelText);\n        }\n    }\n  };\n\n  const undoSelection = () => {\n    let lastSelectedIndex;\n    if (currentPair.length > 0) {\n      lastSelectedIndex = currentPair.pop();\n      setCurrentPair([...currentPair]);\n    } else if (selectedPairs.length > 0) {\n      const lastPair = selectedPairs[selectedPairs.length - 1];\n      lastSelectedIndex = lastPair.pop();\n      if (lastPair.length === 0) {\n        selectedPairs.pop();\n      } else {\n        selectedPairs[selectedPairs.length - 1] = lastPair;\n      }\n      setSelectedPairs([...selectedPairs]);\n    }\n\n    if (lastSelectedIndex !== undefined) {\n      const updatedSelectionCount = { ...selectionCount };\n      if (updatedSelectionCount[lastSelectedIndex] > 0) {\n        updatedSelectionCount[lastSelectedIndex]--;\n      }\n      setSelectionCount(updatedSelectionCount);\n    }\n  };\n\n  const getLabel = (index) => {\n    const occurrences = selectedPairs.flat().filter(i => i === index).length + (currentPair.includes(index) ? 1 : 0);\n    let label = '';\n\n    selectedPairs.forEach((pair, pairIndex) => {\n      pair.forEach((elementIndex, elementPosition) => {\n        if (elementIndex === index) {\n          label += `${pairIndex + 1}${elementPosition === 0 ? 'A' : 'B'} `;\n        }\n      });\n    });\n\n    if (currentPair.includes(index) && occurrences < 2) {\n      label += `${selectedPairs.length + 1}A `;\n    }\n\n    return label.trim();\n  };\n\n  return (\n    <>\n    <button onClick={undoSelection} className=\"undo-button\">Undo Selection</button>\n\n    <div style={{ position: 'relative', display: 'inline-block' }}>\n      <img ref={imageRef} src={imagePath} alt=\"Annotated Invoice\" style={{ maxWidth: '100%' }} />\n      <svg style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}>\n        {blobs.map((blob, index) => {\n          const [x, y, width, height] = blob.coordinates.map(coord => coord * scaleFactor);\n          const isSelected = selectedPairs.flat().includes(index) || currentPair.includes(index);\n          const label = getLabel(index);\n\n          return (\n            <g key={index} onClick={() => addSelection(index)}>\n              <rect\n                x={x} y={y} width={width} height={height}\n                fill=\"none\" stroke={isSelected ? 'blue' : 'red'} strokeWidth=\"2\"\n                style={{ pointerEvents: 'all', cursor: 'pointer' }}\n              />\n              {label && (\n                <text\n                  x={x + 5} y={y + 20}\n                  fill=\"blue\" fontSize=\"15\"\n                  style={{ pointerEvents: 'none' }}\n                >\n                  {label}\n                </text>\n              )}\n            </g>\n\n          );\n        })}\n      </svg>\n\n    </div>\n    {isVariationsModalOpen && (\n      <LabelVariationsModal\n        isOpen={isVariationsModalOpen}\n        onSave={handleSaveVariations}\n        onCancel={handleCancelModal}\n        currentLabelText={currentLabelText}\n      />\n    )}\n    </>\n  );\n}\n\nexport default InteractiveAnnotatedImage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}